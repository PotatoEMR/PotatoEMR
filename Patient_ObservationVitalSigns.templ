package main

import (
	"encoding/json"
	"errors"
	"github.com/PotatoEMR/PotatoEMR/utils"
	r4 "github.com/PotatoEMR/simple-fhir-client/r4"
	r4Client "github.com/PotatoEMR/simple-fhir-client/r4Client"
	"slices"

	"fmt"
	"net/http"
)

// https://build.fhir.org/observation-vitalsigns.html
func patient_ObservationVitalSigns(w http.ResponseWriter, req *http.Request) {
	patId := req.PathValue("patId")
	patEverything, err := client.PatientEverythingGrouped(patId)
	//map of observation time collected -> observation vital code -> observation
	//so we can create a spreadsheet ish thing
	//with a column of vitals collected at a given time
	//that has a row for each obs in vital signs panel
	vitalsByTimeAndCode := make(map[string]map[string]r4.Observation)
	for _, obs := range patEverything.Observations {
		obsTime, obsTimeErr := utils.ObservationTime(obs)
		if obsTimeErr == nil {
			for _, vitalSignsCode := range r4.VSObservation_vitalsignresult {
				for _, coding := range obs.Code.Coding {
					if coding.Code != nil && *coding.Code == *vitalSignsCode.Code {
						if vitalsByTimeAndCode[*obsTime] == nil {
							//might think this could go in higher loop, but we want the outer time map to only have times for vital sign observations
							//observation could be a normal observation with some other code, in which case doesn't make time -> code map
							vitalsByTimeAndCode[*obsTime] = make(map[string]r4.Observation)
						}
						vitalsByTimeAndCode[*obsTime][*vitalSignsCode.Code] = *obs
					}
				}
			}
		}
	}

	if err != nil {
		ErrorMsg(err).Render(req.Context(), w)
		return
	}
	if len(patEverything.Patients) != 1 {
		ErrorMsg(errors.New("Patient id "+patId+" not found on server "+client.BaseUrl)).Render(req.Context(), w)
		return
	}
	pat := patEverything.Patients[0]
	if pat.Id == nil || *pat.Id != patId {
		ErrorMsg(errors.New("Server returned patient without id "+patId)).Render(req.Context(), w)
		return
	}
	T_ObservationVitalSigns(pat, patEverything, vitalsByTimeAndCode).Render(req.Context(), w)
}

type VitalsTimeAndValues struct {
	Time   r4.FhirDateTime    `json:"time"`
	Values map[string]float64 `json:"values"`
}

func patient_ObservationVitalSignsCreate(w http.ResponseWriter, req *http.Request) {
	patId := req.PathValue("patId")
	var observations VitalsTimeAndValues
	if err := json.NewDecoder(req.Body).Decode(&observations); err != nil {
		ErrorMsg(errors.New("Could not parse submitted vital sign observations")).Render(req.Context(), w)
		fmt.Println(err)
		return
	}
	loincSystem := r4.VSObservation_vitalsignresult[0].System
	for _, codeAndName := range codeAndNames {
		obsFloat, ok := observations.Values[codeAndName.name]
		if ok {
			obsQty := r4.Quantity{Value: &obsFloat, Unit: &codeAndName.unit}
			obsCoding := r4.Coding{Code: &codeAndName.code, System: loincSystem}
			obsCodeableConcept := r4.CodeableConcept{Coding: []r4.Coding{obsCoding}}
			patRef := r4.Patient{Id: &patId}.ToRef()
			newObs := r4.Observation{Subject: &patRef, EffectiveDateTime: &observations.Time, ValueQuantity: &obsQty, Code: obsCodeableConcept}
			_, err := client.CreateObservation(&newObs)
			if err != nil {
				ErrorMsg(errors.New("ObservationVitalSignsCreate failed to create obs: "+err.Error())).Render(req.Context(), w)
				fmt.Println("err")
				return
			}
		}
	}
	patient_ObservationVitalSigns(w, req)
}

type codeAndName struct {
	code string
	name string
	unit string
}

var codeAndNames = []codeAndName{
	{code: "29463-7", name: "Body weight", unit: "kg"},
	{code: "8302-2", name: "Body height", unit: "cm"},
	{code: "9843-4", name: "Head circumference", unit: "cm"},
	{code: "39156-5", name: "Body mass index", unit: "kg/m²"},
	{code: "9279-1", name: "Respiratory Rate", unit: "/min"},
	{code: "8867-4", name: "Heart rate", unit: "/min"},
	{code: "2708-6", name: "Oxygen saturation", unit: "%O2"},
	{code: "8310-5", name: "Body temperature", unit: "°C"},
	{code: "85354-9", name: "Blood pressure systolic and diastolic", unit: "mm[Hg]"},
	{code: "8480-6", name: "Systolic blood pressure", unit: "mm[Hg]"},
	{code: "8462-4", name: "Diastolic blood pressure", unit: "mm[Hg]"},
}

templ T_ObservationVitalSigns(pat *r4.Patient, patEverything *r4Client.ResourceGroup, vitalsByTimeAndCode map[string]map[string]r4.Observation) {
	@patient_Base_Nav(pat, patEverything, get_patient_observationVitalSigns) {
		<h3>Vital Signs</h3>
		<style>
		table {
		border-collapse: collapse;
		}
		th, td {
			text-align: start;
		border: 1px solid black;
		padding: 5px;
		}
		</style>
		{{
			timeKeys := make([]string, 0)
			for k, _ := range vitalsByTimeAndCode {
				timeKeys = append(timeKeys, k)
			}
			slices.Sort(timeKeys)
		}}
		<form
			id="vitalsForm"
			hx-post={ fmt.Sprintf(post_patient_observationVitalSigns, *pat.Id) }
			hx-target="body"
			hx-ext="form-json"
			hx-push-url="false"
			hx-indicator="#vitalsForm"
			class="htmx-indicator"
		>
			<div style="width: fit-content;">
				<table>
					<tr>
						<th>Time</th>
						for _, k := range timeKeys {
							<td>{ k }</td>
						}
						<td><input name="time" required type="datetime-local"/></td>
					</tr>
					for _, codeAndName := range codeAndNames {
						<tr>
							<td>{ codeAndName.name }</td>
							for _, timeKey := range timeKeys {
								{{ obs, ok := vitalsByTimeAndCode[timeKey][codeAndName.code] }}
								if ok {
									<td>{ utils.ObservationValueString(&obs) }</td>
								} else {
									<td></td>
								}
							}
							<td>
								//put values dot for everything except time to parse into string->float64 map
								<input name={ "values." + codeAndName.name } type="number" step="0.01" style="width: 80px; margin-right: 2px;"/>
								//could make unit a select but right now just taking a single unit for each
								//would also need to parse unit input when parsing instead of just taking codeAndName.unit
								<span>{ "(" + codeAndName.unit + ")" }</span>
							</td>
						</tr>
					}
				</table>
				<div style="text-align: right; margin-top: 2px;">
					<button type="submit">Save New Vitals Panel</button>
				</div>
			</div>
		</form>
	}
}
