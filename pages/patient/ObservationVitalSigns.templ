package pages_patient

import (
	"encoding/json"
	"errors"
	"github.com/PotatoEMR/PotatoEMR/pages"
	"github.com/PotatoEMR/PotatoEMR/utils"
	r4 "github.com/PotatoEMR/simple-fhir-client/r4"
	r4Client "github.com/PotatoEMR/simple-fhir-client/r4Client"
	"slices"

	"fmt"
	"net/http"
)

// https://build.fhir.org/observation-vitalsigns.html
func ObservationVitalSigns(w http.ResponseWriter, req *http.Request) {
	patId := req.PathValue("patId")
	patEverything, err := Client.PatientEverythingGrouped(patId)
	//map of observation time collected -> observation vital code -> observation
	//so we can create a spreadsheet ish thing
	//with a column of vitals collected at a given time
	//that has a row for each obs in vital signs panel
	vitalsByTimeAndCode := make(map[string]map[string]r4.Observation)
	for _, obs := range patEverything.Observations {
		obsTime, obsTimeErr := utils.ObservationTime(obs)
		if obsTimeErr == nil {
			for _, vitalSignsCode := range r4.VSObservation_vitalsignresult {
				for _, coding := range obs.Code.Coding {
					if coding.Code != nil && *coding.Code == *vitalSignsCode.Code {
						if vitalsByTimeAndCode[*obsTime] == nil {
							//might think this could go in higher loop, but we want the outer time map to only have times for vital sign observations
							//observation could be a normal observation with some other code, in which case doesn't make time -> code map
							vitalsByTimeAndCode[*obsTime] = make(map[string]r4.Observation)
						}
						vitalsByTimeAndCode[*obsTime][*vitalSignsCode.Code] = *obs
					}
				}
			}
		}
	}

	if err != nil {
		pages.ErrorMsg(err).Render(req.Context(), w)
		return
	}
	if len(patEverything.Patients) != 1 {
		pages.ErrorMsg(errors.New("Patient id "+patId+" not found on server "+Client.BaseUrl)).Render(req.Context(), w)
		return
	}
	pat := patEverything.Patients[0]
	if pat.Id == nil || *pat.Id != patId {
		pages.ErrorMsg(errors.New("Server returned patient without id "+patId)).Render(req.Context(), w)
		return
	}
	T_ObservationVitalSigns(pat, patEverything, vitalsByTimeAndCode).Render(req.Context(), w)
}

func ObservationVitalSignsCreate(w http.ResponseWriter, req *http.Request) {
	patId := req.PathValue("patId")
	fmt.Println("vsc", patId)
	var observations map[string]string
	if err := json.NewDecoder(req.Body).Decode(&observations); err != nil {
		pages.ErrorMsg(errors.New("failed to unmarshal observation json")).Render(req.Context(), w)
		return
	}
	time, err := utils.ParseHTMLDateTimeLocal(observations["time"])
	if err != nil {
		pages.ErrorMsg(errors.New("failed to parse observation time "+err.Error())).Render(req.Context(), w)
		return
	}
	obsTime := r4.FhirDateTime{time}
	loincSystem := "HMMM"
	for _, codeAndName := range codeAndNames {
		obs, ok := observations[codeAndName.name]
		if ok {
			obsCoding := r4.Coding{Code: &codeAndName.name, System: &loincSystem}
			obsCodeableConcept := r4.CodeableConcept{Coding: []r4.Coding{obsCoding}}
			newObs := r4.Observation{EffectiveDateTime: &obsTime, ValueString: &obs, Code: obsCodeableConcept}
			fmt.Println(newObs)
		}
	}
	ObservationVitalSigns(w, req)
}

type codeAndName struct {
	code string
	name string
}

var codeAndNames = []codeAndName{
	{code: "29463-7", name: "Body weight"},
	{code: "8302-2", name: "Body height"},
	{code: "9843-4", name: "Head circumference"},
	{code: "39156-5", name: "Body mass index"},
	{code: "9279-1", name: "Respiratory Rate"},
	{code: "8867-4", name: "Heart rate"},
	{code: "2708-6", name: "Oxygen saturation"},
	{code: "8310-5", name: "Body temperature"},
	{code: "85354-9", name: "Blood pressure systolic and diastolic"},
	{code: "8480-6", name: "Systolic blood pressure"},
	{code: "8462-4", name: "Diastolic blood pressure"},
}

templ T_ObservationVitalSigns(pat *r4.Patient, patEverything *r4Client.ResourceGroup, vitalsByTimeAndCode map[string]map[string]r4.Observation) {
	@Base_Patient(pat, patEverything, TabVitalSigns) {
		<h3>Vital Signs</h3>
		<style>
		table {
		border-collapse: collapse;
		}
		th, td {
			text-align: start;
		border: 1px solid black;
		padding: 5px;
		}
		</style>
		{{
			timeKeys := make([]string, 0)
			for k, _ := range vitalsByTimeAndCode {
				timeKeys = append(timeKeys, k)
			}
			slices.Sort(timeKeys)
		}}
		<form
			id="vitalsForm"
			hx-post={ "/patient/" + *pat.Id + "/vitalsigns/create/" }
			hx-target="body"
			hx-ext="form-json"
			hx-push-url="false"
			hx-indicator="#vitalsForm"
			class="htmx-indicator"
		>
			<div style="width: fit-content;">
				<table>
					<tr>
						<th>Time</th>
						for _, k := range timeKeys {
							<td>{ k }</td>
						}
						<td><input name="time" required type="datetime-local"/></td>
					</tr>
					for _, codeAndName := range codeAndNames {
						<tr>
							<td>{ codeAndName.name }</td>
							for _, timeKey := range timeKeys {
								{{ obs, ok := vitalsByTimeAndCode[timeKey][codeAndName.code] }}
								if ok {
									<td>{ utils.ObservationValueString(&obs) }</td>
								} else {
									<td></td>
								}
							}
							<td><input name={ codeAndName.name }/></td>
						</tr>
					}
				</table>
				<div style="text-align: right; margin-top: 2px;">
					<button type="submit">Save New Vitals Panel</button>
				</div>
			</div>
		</form>
	}
}
